#### 可达性

1. 所有显式的调用，被称为**根**
   * 全局对象
   * 正在被调用的函数的局部变量和参数
   * 相关嵌套函数里的变量和参数
   * 其他
2. 所有从根引用或者引用链访问的对象

```javascript
let user = {
    name: 'Onion'
}
```

全局变量user指向内存里的{name: 'Onion'}对象。这时对象Onion是**可达**的

```javascript
user = null
```

把user置为null之后，对象不可达，因此会被从内存中清除。

#### 回收算法

* 标记清除
  1. GC标记所有的根
  2. 访问所有变量的引用，并标记他们
  3. 标记所有引用链上的对象
  4. 删除未被标记的对象
* 引用计数：对引用数进行记录（循环引用的情况可能会无法察觉
  * 一旦数据不再有用，最好将其设置为null



#### 内存泄露

> 申请的内存得不到释放，GC回收不了。创建的对象一直保留在内存中，**可达**但是把引用地址搞丢了，没法操作它，而GC又无法回收。因此会导致内存泄漏。
>
> 内存泄漏堆积耗尽系统內存。

1. 意外的全局变量
2. 忘记清空计时器
3. 闭包里的循环引用