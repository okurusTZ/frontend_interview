

### HTTP报文

HTTP报文就是浏览器和服务器通信时发送及响应的数据块。

浏览器向服务器请求数据，发送请求报文；服务器向浏览器返回数据，返回响应报文。

##### 报文信息主要分为

1. header：附加信息(cookie，缓存信息等)
2. body：HTTP请求真正要传输的部分

### HTTP首部

首部是客户端和服务器分别处理请求和响应所需要的信息。

![img](https://images2015.cnblogs.com/blog/747969/201702/747969-20170217213700816-2042027085.png)

#### 格式

首部字段名: 字段值

#### 字段类型

* 通用首部字段

  请求和响应报文都会使用的首部

   ![img](https://images2015.cnblogs.com/blog/747969/201702/747969-20170217213940879-276855677.png)

* 请求首部字段

  请求的附加内容、客户端信息、响应内容优先级等

* 响应首部字段

  响应的附加内容

* 实体首部字段

  针对请求报文和响应报文的实体部分使用的首部



#### GET&POST的区别

1. get是幂等的，而post不是

2. get请求可以被缓存，post不可以

3. post的安全性高于get

4. get提交请求的数据会附在URL之后以?分割URL和传输数据，多个参数用&连接；

   post提交的数据在HTTP包中

5. get请求会保存在浏览器历史中，post不会

### HTTP缓存机制

#### 强制缓存

强制缓存在数据未失效的情况下，可以直接使用缓存数据。那么**如何判断缓存数据是否失效**呢？

因为没有数据时，会向服务器请求数据，此时会返回数据和缓存规则，缓存规则包含在响应的header中。对于强制缓存来说，header中会有两个字段来标明失效规则。

* expires

  服务端返回的到期时间，下一次请求时，如果请求时间小于到期时间，直接使用缓存数据。（不常使用，而且因为服务端与客户端的时差问题，会导致命中误差。

* cache-control

  * private：客户端可以缓存（默认）
  * public：客户端和代理服务器都可以缓存
  * max-age=xxx：在xxx秒后缓存内容失效
  * no-cache：需要使用对比缓存来验证缓存数据
  * no-store：所有的内容都不会缓存

![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210135521072-1812985836.png)

#### 对比缓存

需要比较判断是否可以使用缓存。

请求数据时，客户端将备份的**缓存标识**发送给服务器，服务器根据标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。

服务器在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不需要把报文主体返回给客户端。

**缓存标识**在请求header和响应header之间进行传递。

* last-modified：服务器在响应请求时，告诉浏览器的最后修改时间（第一次请求时
* if-modified-since：再次请求服务器时，通过此字段通知服务器上次请求时服务器返回资源的最后修改时间。服务器收到请求后，发现有该标识，则与被请求资源的最后修改时间进行对比。
  * 如果最后修改时间大于if-modified-since，则资源又被改动，返回200
  * 如果小于或等于，则资源无新修改，则相应304，可以使用缓存
* Etag：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（第一次请求时，优先级高于last-modified
* if-none-match： 再次请求服务器时，通过此字段通知服务器客户端缓存数据的唯一标识。
  * 如果两者不同，则资源被改动，返回200
  * 如果相同，则资源无改动，返回304，可继续使用缓存

![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141716838-764535017.png)