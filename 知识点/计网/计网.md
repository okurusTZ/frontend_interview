### OSI七层模型

* 应用层
* 表示层
* 会话层
* 传输层
* 网络层
* 数据链路层
* 物理层



TCP\IP模型

* 应用层
* 传输层
* 网络层
* 网络接口层





#### 物理层

为上层协议提供了一个传输数据的可靠的物理媒体，确保原始的数据可以在各个物理媒体上传输。

#### 数据链路层

1. 将源自网络层来的数据**可靠**地传输到相邻节点的目标机的网络层。
2. 基本的数据单位为帧
3. 主要的协议：以太网协议
4. 两个重要的设备：网桥和交换机
5. 作用
   * 物理地址寻址
   * 数据的成帧（以帧为单位传输
   * 流量控制、数据检错和重发

#### 网络层

路径的选择、路由和逻辑寻址

#### 传输层

将上层数据**分段**并提供**端到端**的可靠或不可靠的传输，同时处理差错控制和流量控制。

> 根据通信子网的特征，最佳的利用网络资源，为两个端系统的会话层之间提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。

网络层只负责根据网络地址把源节点发送的数据包传输到目标节点，**而传输层负责将数据可靠地传送到对应的端口。**

#### 会话层

管理主机之间的会话进程，负责建立、管理、终止进程之间的会话。

#### 表示层

对信息进行转换，保证一个主机的应用层信息可以被另一个主机理解。

> 包括对数据的加密、压缩、格式转换等

#### 应用层

为操作系统或网络应用提供访问网络服务的接口。

### IP地址

IP地址 = 网络地址 + 主机地址。网络地址的主机号为全0，网络地址代表着整个网络。

由四个字节组成。ABCD类地址的四个字节分配网络地址和主机地址的形式不同。

#### A类地址

第一个字节为网络地址，其他三个字节为主机地址，第一个字节的最高位固定为0

* 地址范围： 1.0.0.0 - 127.255.255.255
* 私有地址： 10.0.0.0 - 10.255.255.255（在互联网上不使用，而在局域网中使用的地址
* 保留地址： 127.0.0.0 - 127.255.255.255（用于循环测试

#### B类地址

两个字节的网络地址和两个字节的主机地址组成，网络地址的最高位必须为10.

* 地址范围： 128.0.0.0 - 191.255.255.255
* 私有地址： 172.16.0.0 - 172.31.255.255
* 保留地址： 169.254.X.X （用于临时分配IP地址

#### C类地址

3字节的网络地址和1字节的主机地址，网络地址的最高位必须是110

* 地址范围：192.0.0.0 - 233.255.255.255
* 私有地址：192.168.X.X

#### D类地址

第1个字节以1110开始，是一个专门保留的地址，不指向特定的网络，主要被动在多点广播中。用来一次寻址一组计算机，它表示共享同一协议的一组计算机。**一对多的通信**

* 不分网络地址和主机地址，第1个字节前四位固定为1110
* 范围：244.0.0.0 - 239.255.255.255

#### E类地址

以11110开始，为将来保留使用。

* 全零对应当前主机，全1就是当前子网的广播地址。
* 地址范围：240.0.0.0 - 255.255.255.255

#### 广播地址

主机号全为1，当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。

#### 子网掩码

用于解决网络号占位太多而主机号位太少的情况。对主机号的高位部分取作为子网号，创建更多某类地址的子网。但创建子网的时候，每个子网上的可用主机地址数目会比原先减少。

子网掩码是标志两个IP地址是否同属于一个子网的。其每一个为1代表该位是网络位，为0代表主机位。如果两个IP地址在子网掩码的按位与计算下结果相同，即在同一个子网中。

无须再划分成子网的IP地址，子网掩码很简单

* A类： 255.0.0.0

* B类： 255.255.0.0

* C类：255.255.255.0

还需要将其高位主机位再做划分的子网网络号，剩下的是每个子网的主机号。

* 已知子网数计算

  * 把子网数转化为二进制表示

    168.195.0.0划分成27个子网： 27=11011

  * 取得二进制的位数

    位数N=5

  * 取得该IP地址的类子网掩码

    将255.255.0.0主机部分的前N位置1即可获得对应的子网掩码，得到255.255.248.0

* 已知主机数计算

  * 将主机数转化为二进制
  * 如果主机数小于或等于254，取得该主机的二进制位数，为N，这里N肯定小于8；如果大于254，说明主机地址将占据不止8位。
  * 将子网掩码的主机位全部置1，然后从后往前将后N为置为0

  > 1.68.195.0.0划分为若干子网，每个子网有700台主机。
  >
  > 700 = 1010111100
  >
  > N = 10
  >
  > 255.255.255.255 的后10位置为0得到255.255.252.0

* 根据每个网络的主机数进行子网地址规划和计算子网掩码

  > 假如一个子网有10台主机，那么需要的IP地址为
  >
  > 10+1+1+1 = 13
  >
  > **第一个1是这个网络连接时所需要的网关地址（用于在不同的网络之间进行转发信息的地址，即一个网络通向其他网络的IP地址），后面两个是网络地址和广播地址**
  >
  > 13 < 16，所以主机号为4位。256-16=240，所以子网掩码为
  >
  > 255.255.255.240

### ARP/PARP协议

##### ARP协议，是根据IP地址获取物理地址的一个TCP/IP协议。

> 主机发送信息的时候将包含目标IP地址的ARP请求进行广播，并接受返回消息，以确定目标的物理地址。收到返回后，会将该IP地址和物理地址存入本机ARP缓存中并保存一段时间，下次请求的时候直接查询缓存以节约资源。
>
> **ARP命令可以用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系**

查找过程

1. 主机A根据路由表，确定需要访问的主机B的IP地址，然后在自己的ARP缓存中检查是否有B的物理地址。
2. 如果没有，就ARP请求帧广播到本地网络上的所有主机。此时A的IP和MAC地址都包括在ARP请求里，本地网络上的每台主机都会检查自己的IP地址是否与对应的请求相匹配。如果不匹配就丢弃掉ARP请求。
3. 主机B确定了ARP请求里的IP地址和自己的匹配，将A的IP和MAC地址映射添加到自己本地的ARP请求中。
4. B将自己的IP和MAC地址当做ARP回复消息发送回A
5. 主机A收到ARP回复请求后，利用B的IP和MAC地址映射更新自己本地的ARP缓存。本地缓存是有生命周期的，生命周期结束后，将再次重复上述的过程。当知道B的MAC地址后，A就可以向B发送IP通信了。

##### RARP：把主机的物理地址转换为IP地址。

工作流程类似，但是是向本地网段上的RARP服务器进行请求，检查对应的RARP列表，查找对应的IP地址。如果存在就给源主机发一个响应数据包并把IP地址提供。如果不存在，就不做任何响应。

#### 路由选择协议

##### RIP协议

如果路由的跳数大于15跳，就会丢弃数据包。

##### OSPF协议

开放式最短路径优先，选择路由的度量标准是带宽、延迟

#### TCP/IP协议

TCP负责发现传输的问题，一有问题就请求重传，保证所有的数据安全正确地传输到目的地。IP给因特网的每一台联网设备规定一个地址。

##### IP

接受更低层（网络接口层）发来的数据包，并把该数据包发送到更高的层。相反也把TCP或UDP层的数据包传到更低的层。

**不可靠**，没有做任何事来确认数据包是否按顺序、被破坏。IP数据包里有发送它的主机的地址和接受它的主机地址。

##### TCP

面向连接。可靠。流量控制。

![img](https://www.runoob.com/wp-content/uploads/2018/09/1538030297-3779-20150904110054856-961661137.png)

#### DNS协议

DomainNameSystem，**把URL转换为IP地址**。每个域名都有一个对应的唯一的IP地址，DNS就是进行域名解析的服务器。

#### HTTP协议

* GET

  请求读取由URL所标志的信息

* POST

  给服务器添加信息

* PUT

  在给定的URL下存储一个文档

* DELETE

  删除给定URL所标志的数据

##### GET和POST的区别

1. GET是在服务器上获取数据，POST是向服务器传输数据
2. GET是把参数数据队列加到提交表单的action属性所指的URL中，值和表单内字段一一对应，在URL可以看到
3. GET传送数据小，不能大于2kb；POST一般没有限制
4. GET用于获取信息，应该是安全且幂等的
   * 安全：不修改信息，不产生负作用
   * 幂等：对同一个URL的多个请求返回同样的结果

#### 举例

在浏览器里输入http://www.baidu.com后执行的全过程

1. DNS解析，把域名解析成IP地址
2. TCP连接
   * 三次握手
   * 全双工通信
3. 发送HTTP请求
   * 请求报文：请求行、请求头、请求体
   * GET/POST/PUT/DELETE/PATCH/HEAD/OPTIONS/TRACE
4. 服务器处理请求并返回HTTP报文
   * 响应行、响应头部、响应主体
   * 状态码：
     * 1xx：请求已接收，继续处理
     * 2xx：请求成功
     * 3xx：重定向
     * 4xx：客户端错误
     * 5xx：服务器端错误
   * 具体请求
     * 200： 请求成功
     * 204：请求成功，但没有结果返回
     * 206：请求一部分资源，成功响应，返回一部分资源
     * 301：永久重定向
     * 302：临时重定向
     * 303：对应请求资源存在另一个URL，应该使用GET方法定向获取请求的资源
     * 304：找到了资源，但请求条件不符合
     * 400：请求报文存在语法错误
     * 401：需要认证/认证失败
     * 403：请求被服务器拒绝
     * 404：服务器上无法找到请求的资源
     * 500：服务器执行请求时发生错误
     * 503：服务器超负载或者停机维护
5. 浏览器解析渲染页面、
   * 根据HTML解析DOM树，如果遇到script标签，构建会停止直到脚本执行完毕。
   * 根据CSS解析生成CSS规则树
   * 结合DOM树和CSS规则树，生成渲染树
   * 根据渲染树计算每个节点的信息
     * 布局：计算每一个渲染对象的位置和尺寸
     * 回流：布局完成后，发现某个部分的变化影响了布局，需要倒回去重新渲染
   * 根据计算好的信息绘制页面
     * 重绘：某个元素的背景、文字颜色发生改变，不影响元素周围或者内部的布局，只会引起重绘
     * 回流：某个元素的尺寸发生变化，需要重新计算渲染树，重新渲染
6. 断开连接：四次挥手