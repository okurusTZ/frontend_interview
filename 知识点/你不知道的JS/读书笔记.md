传统语言的编译过程

* 分词/词法分析
  * 把字符串分解成有意义的代码块
* 解析/语法分析
  * 把词法单元流转换成一个由元素逐级嵌套所组成的代表程序语法结构的树。AST
* 代码生成
  * 把AST转换为可执行代码

#### 引擎、作用域、编译器的对话

而JS的编译过程不是发生在构建前的。

* 引擎：负责JS程序的编译和执行
* 编译器：负责语法分析和代码生成
* 作用域：收集并维护由所有声明的标识符组成的一系列查询。



e.g.
`var a = 2;`

编译器：将这段程序分解成词法单元，构建成一个树结构。

1. 遇到`var a`，编译器先在作用域中询问，是否已经有一个该名字的变量存储在对应的作用域中，如果有，就忽视这个请求。如果没有，就要求作用域在当前作用域的集合里声明一个新的变量，叫做a。
2. 编译器为引擎生成所需要的代码，这些代码主要是被用来处理`a = 2`的赋值操作。引擎运行对应代码的时候，会先询问，作用域里是否有`a`这个变量，如果有，就使用这个变量，如果没有，引擎就继续寻找这个变量。
3. 如果最终找到了`a`，就会把2赋值给它，如果没有找到，就会抛出一个异常。

**总结**：变量的赋值其实是两个操作，首先编译器会查找是否在当前作用域里已经生成了这个变量，如果没有的话，就生成。然后**在运行时**引擎会在作用域里查找该变量并进行赋值。



##### 引擎如何查找变量？

LHS查询和RHS查询。其中L和R分别是左右的意思，代表查询的变量是在赋值操作的左侧还是右侧。

很明显我们需要找到的变量是在赋值操作左侧的，因此就要使用的是**LHS查询**

`console.log(a)`这里对a的引用是RHS引用，因为没有任何的赋值操作。需要的是查找并取得a的值。

`a = 2`这里对a则是LHS引用，因为我们其实不关心a当前的值是多少，只是想为`=2`这个赋值操作找到一个目标对象。

```javascript
function foo(a) {
    // 这里有个隐式的LHS，就是把外部传入的2赋值给了a
    // 同时，也有对a和console的RHS引用
    console.log(a); // 2
}
// 对foo进行了RHS查询，实际上就是取得了foo的值
foo(2);
```

```javascript
function foo(a) {
    // 隐式地对a进行了LHS查询，把2赋值给a
    // 对b进行LHS查询，对a进行RHS查询
    var b = a;
    // 对a和b进行RHS查询
    return a + b;
}
// 对c进行LHS查询，对foo进行RHS查询
var c = foo(2);
```

#### 1.3 作用域嵌套

作用域之间是有嵌套的，当在当前作用域查找不到对应的变量时，就会在外层作用域中继续查找，直到找到该变量，或者抵达最外层作用域为止。

```javascript
function foo(a) {
    // 这里函数执行时，对b进行了一次RHS查询，但是无法在foo函数内部的作用域内完成
    // 可以在上一级作用域中完成，这里就是全局作用域
    console.log(a + b);
}
var b = 2;
foo(2); // 4
```

因此就可以得到一条作用域链。可以把作用域链设想成一座大楼，当前作用域在最底层，每次进行LHS和RHS查询的时候，都会在当层查找，如果找不到，就向上一层继续查找，直到到达顶层，还没有找到的话就停止操作。

#### 1.4 异常

为什么要区分RHS和LHS？

> 因为变量还没有声明的时候，两种查询的行为是不一样的

```javascript
function foo(a) {
    // 这里会对b进行一次RHS查询，而此时作用域链上是没有b的
    console.log(a + b);
    var b = a;
}
foo(2);
```

RHS查询如果找不到所需的变量，会抛出ReferenceError的异常。

而**非严格模式下**，如果LHS查询在顶层作用域里也找不到所需的变量，全局作用域就会创建一个具有该名称的变量，并将其返回引擎。

> 严格模式是ES5引入的一个概念，会禁止自动或者隐式地创建全局变量。因此严格模式里，也会返回一个相同的错误。