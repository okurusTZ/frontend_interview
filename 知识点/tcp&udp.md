### TCP握手

![img](https://img-blog.csdn.net/20150907213812049)

1. 客户端向服务器发送连接请求报文，SYN=1，seq=x。此时客户端进入SYN-SENT状态
2. 服务器收到请求之后，向客户端发送确认。确认报文中，把SYN和ACK位都置为1，确认号是ack=x+1，同时服务器为自己选择一个初始序列号seq=y。进入SYN-RCVD状态
3. 客户端收到服务器的确认信号，向服务器确认自己收到该信号。ACK=1, 确认号ack=y+1，自己的序号seq=x+1。此时TCP连接建立，客户端进入ESTABLISHED状态。服务器收到客户端的确认之后，也会进入ESTABLISHED状态。

#### 为什么要三次握手？

防止失效的连接请求报文段突然又传到了服务端，从而产生错误，所以需要客户端再次确认。

#### 如果第三次握手中报文段丢失会怎么样？

客户端认为已经建立连接，但服务器没有收到确认信息。如果客户端向服务器写数据，服务器将以**RST包**响应，才会发现建立错误。

> RST包：TCP连接异常终止，用于强制关闭TCP连接



### TCP挥手

![这里写图片描述](https://img-blog.csdn.net/20150907213846032)

1. 客户端向服务器发送释放连接的报文，并停止传输数据，主动关闭TCP连接。FIN=1, seq=u。此时客户端进入FIN-WAIT-1状态。
2. 服务器收到释放报文后，发出确认释放连接的报文，ACK=1，ack=u+1，seq=v。服务器进入CLOSE-WAIT状态。这时候TCP处于半关闭状态，客户端已经没有数据要发送了，但服务器仍然可以向客户端发送数据，且客户端仍要接受。
3. 客户端收到服务器的确认后，进入FIN-WAIT-2状态，等待服务器发送释放连接的报文。如果服务器已经没有要发送的数据了，就向客户端发送释放报文，FIN=1，ack=u+1，seq=w。这时服务器进入LAST-ACK状态，等待客户端的确认。
4. 客户端收到连接释放请求后，发出确认。ACK=1, ack=w+1，seq=u+1，进入TIME-WAIT状态。此时TCP还没有释放掉，在等地啊计时器之后，才进入CLOSED状态。因此客户端进入TIME-WAIT状态后，还要经过4分钟(2 MSL，一个MSL的建议时长为2分钟)才能CLOSED，而服务器只要收到客户端的确认，就进入CLOSED状态。两者都CLOSED之后，连接就完全释放了。

#### 为什么要四次挥手？

1. 保证客户端发送的最后一个ACK报文能够到达服务器。（等待时间是为了防止确认报文丢失
2. 防止已经失效的连接请求报文出现在连接中（下一次连接中出现上一个连接遗留下来的请求报文





### TCP&UDP区别

#### UDP

1. 面向无连接，不需要进行握手，想发送数据就发送数据。不会对数据报文进行拆分和拼接。
   * 发送端，UDP只给数据加一个UDP头标识
   * 接收端，UDP只出去IP报文头
2. 有单播、多播、广播功能：不仅支持一对一，还支持一对多，多对多，多对一
3. UDP是面向报文的：应用程序必须选择合适大小的报文
4. 不可靠性：由于无连接，所以不可靠。发送完数据之后不会确认是否正确接收到数据。没有拥塞控制，以恒定速度发送数据。所以会在网络不好的情况下丢包，但在实时性要求高的场景中被需要。
5. 头部开销小，高效：头部只有八字节，相比TCP的20字节少得多

#### TCP

1. 面向连接： 发送数据之前必须建立连接
2. 仅支持单播：每个TCP传输只有两个端点，只支持一对一
3. 面向字节流：不像UDP那样一个个报文独立传输，而是不保留报文边界的情况下以字节流传输
4. 可靠传输：会判断丢包和传送的顺序，如果规定时间内未收到确认，会重传
5. 提供拥塞控制：网络出现拥塞的时候，减小传输数据的速率和数量

#### 对比

* **是否连接**
* **是否可靠**
* **连接对象个数**
* **传输方式**
* **首部开销**
* **适用场景**



### 滑动窗口拥塞控制

#### 滑动窗口：保证可靠性和流量控制

1. 窗口对应一个可以被发送者发送的字节序列，其连续的范围为窗口
2. 滑动则是指这段运行发送的范围是随着发送过程变化的，方式是按顺序滑动。

> 因为TCP协议是全双工的，所以发送者A和接受者B分别维护一个独立的发送缓冲区和接受缓冲区。发送窗口是发送缓冲区的一部分，所有需要发送的数据都被送入了发送缓存区。
>
> 对于发送窗口来说，有四个概念：
>
> 1. 已发送并得到确认的数据：不在缓冲区或窗口了
> 2. 已发送但未确认：在窗口中（不可用窗口
> 3. 允许发送但未发送：在窗口中（可用窗口
> 4. 暂时不允许发送的数据

![这里写图片描述](https://static.oschina.net/uploads/img/201611/09091606_jp7v.jpg)

每次发送数据成功之后，发送窗口会在缓存区中按顺序移动，将新的数据包含的窗口中准备发送。只有成功发送了数据，即得到对方的确认之后，才会移动滑动窗口离开已经发送的数据。



#### 拥塞控制

发送窗口swnd原来和接收窗口rwnd是约等于的关系，但是加入拥塞窗口cwnd的概念后

swnd=min(rwnd, cwnd)

* 慢启动（慢开始阈值到达前

  **当发送方每收到一个 ACK，就拥塞窗口 cwnd 的大小就会加 1。**（所以是加倍

  开始发送数据的时候，先探测一下，由小到大逐渐增大拥塞窗口的数值。通常在刚开始发送报文的时候，把拥塞窗口设置为最大报文段的数值，每收到一个对新的报文段的确认后，增加最多一个MSS的数值。

* 拥塞避免（慢开始阈值到达后

  **每当收到一个 ACK 时，cwnd 增加 1/cwnd。**（所以是线性

  每经过一个往返时间RTT（数据从网络一端传送到另一端所需的时间），就把发送方拥塞窗口加一，而不是加倍。这样可以先行规律缓慢增长，比慢开始增长速率慢得多。

![img](https://pics5.baidu.com/feed/34fae6cd7b899e51641ef343b7c45035c9950dbb.jpeg?token=f4ca49c9592ffdd834a1671903ea8533)

* 快速重传（区别于超时重传

  ![img](https://pics0.baidu.com/feed/359b033b5bb5c9eaf293c78c235a3f063bf3b3ec.jpeg?token=937d899f2dd68f43cd806eb6c908fae1)

  * 接收到了seq1，ACK回2
  * seq2因为某些原因没收到，seq3先收到，ack回2
  * seq4/5都到了，但还是ack2，因为seq2还没有收到
  * 此时发送端接受到三个一样的确认，就知道seq2还没收到，在定时器过期前，重传seq2

  发生三次**重复确认**，即使没有超时，也会重传。重传完毕，阈值减半。

  即

  cwnd = cwnd/2 ;

  ssthresh = cwnd;

  > 重复确认：丢失的数据报的后续数据包达到接收端的时候，触发给发送端返回确认。这些确认号都是一样的，叫做重复确认。

* 快速恢复

  快速重传后，拥塞窗口被设置到慢开始的阈值（减半），开始线性增长。