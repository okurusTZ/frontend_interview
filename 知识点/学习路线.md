✔︎ 表示个人推荐学习 

 ✔︎ 表示可选择学习 

 ✔︎ 表示不需要严格按照路线的先后顺序，可在任何时间补充这一块的知识 

 ✘ 表示个人不再推荐 

###  计算机网络 

 掌握计算机网络的基础是一名[前端工程师]()的基本素养，建议先学习以下的知识： 

1.  ✔︎ Internet 如何工作 
2.  ✔︎ HTTP 协议 
3.  ✔︎ 浏览器工作机制  
4.  ✔︎ DNS 及其运行机制 
5.  ✔︎了解域名、网站托管 

###  HTML 

1.  ✔︎  学习 HTML 基础，标签、元素、表单验证等等 
2.  ✔︎ 语义化标签 
3.  ✔︎ 了解 Web 无障碍（Accessibility） 
4.  ✔︎ 学习 SEO 优化 

###  CSS 

1.  ✔︎  学习 CSS 基础 
2.  ✔︎  制作布局：浮动、定位、显示、盒模型、网格布局、弹性布局 
3.  ✔︎  响应式设计和媒体查询（@media） 
4.  ✔︎  结合 HTML 制作一个简单的网页作为最佳实践 

###  [JavaScript]() 

1.  ✔︎  学习语法和基本结构 
2.  ✔︎  学习操作 DOM 
3.  ✔︎  学习 Fetch API / Ajax（XHR） 
4.  ✔︎  ES6+ 和模块化 [JavaScript]() 
5.  ✔︎  了解变量提升、事件冒泡机制、作用域、原型、Shadow DOM、严格模式等概念 

###  版本控制 

1.  ✔︎  Git 的基本操作 
2.  ✔︎  创建账号并且学习使用 GitHub 
3.  ✔︎  创建账号并且学习使用 GitLab 

###  Web 安全知识 

1.  ✔︎ HTTPS 
2.  ✔︎ 内容安全策略（CSP） 
3.  ✔︎ 跨域资源共享 
4.  ✔︎ OWASP 安全风险 

------

 上面的内容是[前端]()最基础的部分，建议多花时间，掌握好每一个知识点。 

 从这开始，将进入[前端]()工程化的部分，你可能会接触到很多种不同的框架，并学习使用多种的工具为自己的开发提效。 

###  包管理工具 

 npm 和 yarn 都很好，选择一个学习即可，他们两是相似的 

1.  ✔︎  npm 
2.  ✔︎ yarn 

###  CSS 构架 

 通过使用现代的 CSS 框架和 CSS-in-JS 的书写方式，不用再担心 CSS 的构架问题，但熟悉 BEM 规范是一个不错的选择。 

1.  ✔︎ BEM，一种书写规范 
2.  ✘ OOCSS 
3.  ✘ SMACSS 

###  CSS 预处理器 

 以下三个可选择一个进行学习。 

1.  ✔︎ SCSS 
2.  ✔︎ PostCSS 
3.  ✔︎ Less 

###  构建工具 

1.  任务执行器 
   -  ✔︎ npm scripts 
   -  ✘ Gulp 
2.  代码检查和格式化工具 
   -  ✔︎ Prettier 代码格式化 
   -  ✔︎ ESLint 代码检查 
   -  ✘ StandardJS 
3.  模块打包 
   1.  ✔︎ Webpack 
   2.  ✔︎ Rollup 
   3.  ✔︎ Parcel 

###  [前端]()框架 

 [前端]()框架推荐先学习 React，能理解函数式编程和组件化。Vue 的特点是上手快，中文文档齐全，可以选择性的学习。 

1.  ✔︎ React.js 
   -  ✔︎Redux 
   -  ✔︎ MobX 
2.  ✔︎ Vue.js 
   -  VueX 
3.  ✔︎ Angular 
   -  RxJS 
   -  NgRx 

###  现代 CSS 

1.  ✔︎ Styled Component 
2.  ✔︎ CSS Module 
3.  ✔︎ Styled JSX 
4.  ✔︎ Emotion 
5.  ✘ Radium 
6.  ✘ Glamorou 

###  Web 组件 

1.  ✔︎ HTML 模版 
2.  ✔︎ 自定义元素 
3.  ✔︎ Shadow DOM 

###  CSS 框架 

 CSS 框架有两种，一种是基于 [JavaScript]() 框架开发的应用程序。推荐的框架有： 

1.  ✔︎ Reactstrap 
2.  ✔︎ Material UI 
3.  ✔︎ TailWind CSS 
4.  ✔︎ Chakra UI 

 另外一只是纯 CSS 框架，默认和不和 [JavaScript]() 组件一起使用。 

1.  ✔︎ BootStrap 
2.  ✔︎ Materialize CSS 
3.  ✔︎ Bulma 

###  测试 

 在这里你需要学习使用下面的框架进行单元、集成和功能测试。 

1.  ✔︎ Jest 
2.  ✔︎ react-testing-library 
3.  ✔︎ Cypress 
4.  ✔︎ Enzyme 

###  类型检查器 

1.  ✔︎✔︎ TypeScript 
2.  ✘ Flow 

------

 上面是[前端]()工程化的学习内容，接下来的内容涉及到性能、服务端渲染以及跨端，这一部分[前端]()也叫被称作「大[前端]()」。 

###  PWA 

1.  ✔︎ 学习 PWA 中使用到的 Web API： 
   -  Storage 
   -  Web Sockets 
   -  Service Workers 
   -  定位 
   -  通知 
   -  设备方向 
   -  支付、证书等等 
2.  ✔︎ 计算、测量以及提高性能： 
   -  PRPL 模式 
   -  RAIL 模式 
   -  性能指标 
   -  学习使用 LightHouse 
   -  学习使用 DevTools 

###  服务端渲染 

1.  ✔︎ Next.js （React.js） 
2.  ✔︎ Nuxt.js （Vue.js） 
3.  ✔︎ Universal（Angular） 

###  ✔︎ GraphQL 

1.  ✔︎ Apollo 
2.  ✔︎ Relay Modern 

###  ✔︎ 静态网站生成 

1.  ✔︎ Next.js 
2.  ✔︎ GatsbyJS 
3.  ✔︎ Nuxt.js 
4.  ✔︎ Vuepress 
5.  ✔︎ JekyII 
6.  ✔︎ Hugo 

###  ✔︎ 移动端应用开发 

1.  ✔︎ ReactNative 
2.  ✔︎ Flutter 

###  ✔︎ 桌面应用开发 

1.  ✔︎ Electron 
2.  ✔︎ Carlo 
3.  ✔︎ [Proto]()n Native 

###  ✔︎ WebAssembly 

 总结完毕，不由得感叹[前端]()生态真是丰富多彩，要学的东西很多，自己不懂的也很多，有些知识点也是浅尝辄止。虽然有这么多的方向，但还是需要找到一个点能够深挖。 

 如果你是[前端]()的初学者，也不要被这些框架给吓到，学好基础然后加以实践更为重要。 

 上面推荐的 Roadmap GitHub 仓库里也有后端以及 DevOps 的学习路线，可以自行浏览，如果有时间我也会整理出一版文字版以供大家参阅。 

 Keep Learning，持续精进。





### HTML的块级元素和行内元素

#### 块级元素

占据父元素（容器）的整个空间，通常会另起一个新行

```html
<p>This paragraph is a block-level element; its background has been colored to display the paragraph's parent element.</p>
```

```css
p { background-color: #8ABB55; }
```

![image-20210110225643644](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210110225643644.png)

##### 用法

- 块级元素只能在<body>元素内
- 块级元素会新起一行
- 块级元素包含行内元素和其他块级元素，这种结构上的包含继承区别可以使块级元素创建比行内元素更大型的结构

#### 行内元素

一个行内元素只占据他对应标签的边框所包含的空间

```html
<p>This <span>span</span> is an inline element; its background has been colored to display both the beginning and end of the inline element's influence</p>
```

```Css
span { background-color: #8ABB55; }
```

![image-20210110225633202](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210110225633202.png)

- 行内元素只能包含数据和其他行内元素
- 行内元素不会以新行开始

##### 行内元素

- [b](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/b), [big](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/big), [i](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/i), [small](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/small), [tt](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/tt)
- [abbr](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/abbr), [acronym](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/acronym), [cite](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/cite), [code](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/code), [dfn](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/dfn), [em](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/em), [kbd](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/kbd), [strong](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/strong), [samp](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/samp), [var](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/var)
- [a](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a), [bdo](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/bdo), [br](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/br), [img](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Img), [map](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/map), [object](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object), [q](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/q), [script](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Script), [span](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/span), [sub](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/sub), [sup](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/sup)
- [button](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button), [input](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input), [label](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/label), [select](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/select), [textarea](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/textarea)



#### img的data-src属性和懒加载

```html
<img src="img/loading.png" alt="1" data-src="img/photo-3.jpeg">
```

每当访问一个页面的时候，先把img元素的背景图片替换成一个1*1px的图片的路径，当图片出现在可视区域时，才设置图片真正的路径，让图片显示出来。这就是懒加载。

1. 创建一个自定义属性data-src存放真正需要显示的图片路径，img自带的src放一张大小为1*1的图片路径
2. 页面滚动至此图片出现在可视区域的时候，用JS取到该图片的data-src赋值给src



#### data-*属性

用于嵌入自定义数据，可以被JS所利用，创建更好的用户体验

```html
<ul>
    <li data-animal-type="鸟类">喜鹊</li>
    <li data-animal-type="鱼类">金枪鱼</li>
    <li data-animal-type="蜘蛛">蝇虎</li>
</ul>
```



#### label-for属性的作用

用于把label和对应的表单元素（id）进行关联

```html
<form>
  <label for="male">Male</label>
  <input type="radio" name="sex" id="male" />
  <br />
  <label for="female">Female</label>
  <input type="radio" name="sex" id="female" />
</form>
```

也可以隐式地关联

```html
<label>Date of Birth: <input type="text" name="DofB" /></label>
```

不需要for属性和id属性，通过在label标签中放input来连接。

### **runtime-only 和 runtime-compiler**

#### 1.区别

vue程序的运行过程：

template->解析template->ast(抽象语法树)->compile->render(function)->virtual DOM->真实的DOM，UI

**runtime-compiler:**（也可以直接使用render函数）

template -> ast -> render -> vdom -> UI

**runtime-only:** (解析.vue文件时，会把template文件解析成render，由vue-template-compiler处理)

render -> vdom -> UI

`render： function(createElement) {return aaa}`

直接用使用render进行渲染，不识别template（性能更高，代码量更少）



#### 2.对比

##### 1.runtime-only比runtime-compiler轻6KB

##### 2.runtime-only更快

##### 3.runtime-only只识别render函数，不识别template，.vue文件中的也是被vue-template-compiler编译成了js



### 路由

提供两种机制：路由和转送

- 路由决定数据包从来源到目的地的路径
- 转送将输入端的数据转移到合适的输出端

后端路由：后端处理URL和页面之间的映射关系

缺点：整个页面的模块都有后端人员编写和维护，前端人员也需要PHP和java来编写页面代码。HTML和数据以及对应逻辑混杂在一起，对于编写和维护来说很糟糕。



### url的hash和html的history

```javascript
location.hash = 'bar'//跳转到bar
history.pushState({},'','demo')//跳转到demo，类似于压栈操作
history.pushState({},'','about')
history.back()//回到demo页面，类似于出栈操作
history.go(-1)//等同于back操作，回到上一个页面
//-2:回到上两个页面，2：跳转到向前第二个页面
history.go(1) = history.forward()

history.replaceState({},'','demo')//跳转到demo，但是没有压栈操作，不可返回
```



#### 动态路由

有些路由地址是不确定的，可能会添加上用户的信息

/home（静态

/about （静态

/user/uid=zhangsan（动态



#### 路由的懒加载

打包程序时，js包会变得非常大，影响页面加载。

如果把不同路由对应的组件分割成不同的代码块，当路由被访问的时候才加载对应组件，就可以更加高效了。

##### 懒加载的方法

![image-20210110124153310](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210110124153310.png)

懒加载后，打包对应的js文件增加，且更小（可分块加载

#### build完之后的js代码

app.xxxx：当前应用程序开发的所有代码（业务代码

manifest：为打包的代码做底层支撑

vendor： 供应商（第三方vue/vue-router/axios/bs）



#### 路由的嵌套

![image-20210110124506647](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210110124506647.png)

/home/news 就是路由的嵌套

- 创建对应子组件，并在路由映射中配置对应的子路由
- 在组件内部使用<router-view>标签



#### vue-router参数传递的方式

##### params

![image-20210110130552789](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210110130552789.png)

使用：`$route.params.id`

##### Query 

大量数据使用时，用query，因为传递的是对象

![image-20210110132348782](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210110132348782.png)

url: 协议(scheme)://主机(host):端口(port)/路径(path)?查询(query)



##### 可能出现的问题

NavigationDuplicated: Avoided redundant navigation to current location: "/About".

当router-link指向相同的route的时候

> The user is able to click on the products, **but if a product was already clicked (and the component view was already loaded)** and the user attempts to click it again, the error/warning shows in the console.

##### 解决方案

1.使用catch

`router.push('your-path').catch(err => {})`

或者直接在prototype里更改

```js
import Router from 'vue-router';

const originalPush = Router.prototype.push;
Router.prototype.push = function push(location) {
  return originalPush.call(this, location).catch(err => err)
};

Vue.use(Router);
```

2.加条件判断

```js
const path = `/products/${id}`
if (this.$route.path !== path) this.$router.push(path)
```

所有的组件都继承自vue的原型

```javascript
vue.prototype.test = function() {
    // 所有的vue下面的组件都有test方法
}
```

#### 导航守卫

- 全局守卫
- 路由独享守卫（在某个路由内设置
- 组件内的守卫（写在组件内部

监听来回跳转的过程，i.g.动态修改document.title

```javascript
// 前置钩子，在路由器跳转之前
// to: 即将要进入的目标的路由对象
// from：当前导航即将要离开的路由对象
// next：调用该方法后，才能进入下一个钩子
router.beforeEach((to, from, next) => {
  // from -> to
  // 利用元数据来设置
  // 使用matched是为了防止嵌套
  document.title = to.matched[0].meta.title
  // 必须调用
  next()
})

// 后置钩子(hook)
// 不需要next，已经跳转完，不需要next操作
router.afterEach((to, from) => {
    
})
```

#### vue-router: keep-alive

router-view也是一个组件，如果被包在keep-alive里面，所有路径匹配到的视图组件都会被缓存

keep-alive也是vue的内置组件，可以使被包含的组件保留状态，或避免重新渲染（保证其不被销毁）

```html
    <keep-alive>
      <router-view/>
    </keep-alive>

    <!-- 如果此处不加上keep-alive标签，那么每次切换组件，
    router-view对应的内容都会重新创建和销毁，可以利用created()和destroyed()来验证-->
```

只有在使用keep-alive时，activated和deactivated才有效

#### vue的生命周期

![Vue 实例生命周期](https://cn.vuejs.org/images/lifecycle.png)

#### tabbar小案例

![image-20210110160002807](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210110160002807.png)

#### Pormise

回调地狱：回调函数的嵌套

promise就是用于对异步操作进行处理的



##### 什么情况下用promise

有异步操作时，利用promise对异步操作进行封装



#### Promise的三种状态

1. pending：等待状态，正在进行网络请求或定时器没有到时间
2. fulfill：满足状态，主动回调了resolve，就处于该状态，并且会回调then()
3. reject：拒绝状态，当我们主动回调了reject，就出在该状态，并且会回调catch()

#### VueX

状态管理工具，多个组件有共享状态/变量，需要存储在一个对象里（响应式，一旦数据发生改变，界面自动刷新）

##### 管理哪些状态？

多个界面共享的状态：位置、头像、登录状态、用户名称、商品的收藏、购物车中的物品

![image-20210111013718892](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210111013718892.png)

组件修改state必须要经过mutations，可以不经过actions，是因为多个组件有可能同时修改一个state，需要Devtools进行跟踪，确定修改的具体信息方便查错。

![image-20210111022010977](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210111022010977.png)

#### Vuex的核心概念

- state
- getters
- mutation： store状态更新的唯一方式
- action
- module

单一状态树： 状态信息保存在一个store里，管理应用层级内的全部状态



#### mutation的响应规则

1.提前在store中定义好的属性规则（后增加的属性不会更新到响应式系统

2.Mutation里的方法必须是同步方法，因为devtools无法很好地跟踪异步方法（state内记录的信息不会实时更新

```javascript
info: {
    name: 'xinyi',
    age: 18
}

updateInfo(state) {
    // 增加一个对象的属性
    // 此处不会响应式更新
    state.info['address'] = 'shaoxing'
    // 此处可以响应式更新
    Vue.set(state.info, 'address', 'shaoxing')
    
    // 删除一个对象的属性
    // 做不到响应式
    delete state.info.age
    // 响应式
    Vue.delete(state.info, 'age')
}
```



利用变量来做方法名，方便管理和查错

```javascript
export const INCREMENT = 'increment'
```

```javascript
import {
    INCREMENT
} from './...'

// 对于方法名加[]， []内可以以变量的方式做方法名
[INCREMENT]() {
    // 具体的方法
}
```



#### Actions

用于处理一些异步操作，如网络请求

对actions里的方法提交，不能用commit，需要用dispatch



#### Modules

把store分割成模块，每个模块有自己的state、mutations、actions和getters



#### 网络模块

1. 传统的Ajax，基于XMLHttpRequests（XHR）
2. jQuery-Ajax
3. Vue-resource



#### 对象解构

```javascript
const obj = {
    name: 'xinyi',
    age: 18
}

const {name, age} = obj
```

#### 数组解构

```javascript
const names = ['xinyi', 'okurust']
const [name1, name2] = names
```



```javascript
axios.all([])// 放入多个请求的数组，返回一个数组
axios.spread() // 将数组[res1, res2]展开为res1, res2
```

#### 全局配置

利用axios的defaults属性来设置

```javascript
axios.defaults.baseURL = '...'
axios.defaults.headers.post['Content-Tyep'] = ''

// 每个实例可以进行独立的配置
const instance = axios.create({
    baseURL: '...',
    timeout: 10000,
    //....
})

instance({
    url: '/home/data',
    params: {
        type: 'pop',
        page: 1
    }
}).then(res => {
    console.log(res)
})

const instance2 = axios.create({
    baseURL: '...',
    timeout: 5000,
    //....
})
```



#### axios的拦截器

每次得到请求或者相应之后，做出相应的操作

1. config中一些信息不符合服务器要求
2. 发送网络请求时，需要显示一些信息（如打转的符号
3. 某些网络请求（如登录，必须携带特殊的信息

```javascript
  // 2.axios的请求拦截器
  // 两个参数，一个请求成功的函数，一个请求失败的函数
  instance.interceptors.request.use(config => {
    console.log(config)
    // 必须返回，不然被拦截，拿不到config
    return config
  }, err => {
    console.log(err)
  })

  // 响应拦截
  instance.interceptors.response.use(result => {
    // result因为是相应拦截，服务器已经响应
    // do something
      return result
  }, err => {
    // do something
  })
```







# css

选择器 { 属性: 值 }

#### 选择器分类

选择器分为基础选择器和复合选择器，基础选择器由单个选择器组成，又包括：标签选择器、类选择器、id选择器和通配符选择器

1.  标签选择器： 标签名<p>，把所有的标签选择出来

   ```css
   p {
       color: red;
   }
   ```

2. 类选择器，可以单独选择一个或者某几个（.类名）

   ```css
   .active {
       color: red;
   }
   ```

3. id选择器，只能调用一次，不能被别的使用（#id）

   ```css
   #nav {
       color: red;
   }
   ```

4. 通配符选择器（选择所有的标签）

   ```css
   * {
       color: red;
   }
   ```

#### css字体属性

字体系列、大小、粗细、文字样式

```css
p {
    // 多个单词组成的一个字体，用引号包含
    // 多字体的兼容性更好
    font-family: '微软雅黑', Arial, 'Microsoft YaHei';
    
    // 标题标签特殊，需要单独指定大小
    font-size: 20px;
    
    // font-weight: normal|bold|bolder|lighter|number
    font-weight: 400;
    
    // 设置文本风格: normal | italic
    font-style: italic;
}
```

#### css文本属性

```css
div {
    // 文本颜色
    color: red;
    // 对齐文本，水平对齐
    text-align: center;
    // 装饰文本: 下划线、删除线、上划线
    text-decoration: underline;
    // 文本缩进，段落的首航缩进
    text-indent: 10px;
    // 行间距
    line-height: 10px;
}
```

#### 伪类选择器

![image-20210112152031467](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210112152031467.png)

链接伪类的效果会收顺序影响，按照LVHA的顺序来写

#### 小案例

![image-20210112154504237](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210112154504237.png)

分析：由许多<a>组成，但是需要将<a>变为块级元素

```css
    /* 重点：转换为块级元素 */
    a {
      display: block;
      width: 230px;
      height: 40px;
      background-color: #333333;
      font-size: 14px;
      color: white;
      text-decoration: none;
      text-indent: 2em;
      /* 文字居中 */
      line-height: 40px;
    }

    a:hover {
      background-color: #ff6700;
    }
```

![image-20210112154718778](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210112154718778.png)





### css的三大特性

- 层叠性
- 继承性
- 优先性

#### 层叠性

给相同的选择器设置相同的样式（冲突），会被覆盖，遵循就近原则，哪个样式离结构近，就采用哪个样式

#### 继承性

子标签会继承父标签的样式，如颜色字号等，高度、内外边距等不会被继承

```css
body {
    <!-- 这里/后面表示行高 -->
    <!--  这里也可以写成1.5，表示当前元素文字大小的1.5倍-->
    font: 12px/24px Microsoft YaHei;
}
```

#### 优先性

当一个元素指定多个选择器，会有优先级的产生

- 选择器相同，执行层叠性
- 选择器不同，根据权重执行

![image-20210112164329678](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210112164329678.png)

***继承的权重是0，没有直接选中的话会被覆盖·

##### 复合选择器会有权重叠加的问题

```css
/* 权重为 0001 + 0001 = 0002 */
ul li {
    color: red;
}
/* 权重为0001 */
li {
    color: green;
}
/* 权重为 0010 + 0001 = 0011 */
.nav li {
    color: pink;
}
```



### 盒子模型

一个盒子，封装周围的HTML元素

- 边框border
- 内容content
- 内边距padding
- 外边距margin

![image-20210112170123629](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210112170123629.png)

#### 边框border

边框粗细、样式、颜色。

边框会影响盒子的实际大小

![image-20210112170226267](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210112170226267.png)

#### 内边距padding

内容和盒子边缘的距离，padding也会影响盒子的大小。

如果盒子没有指定宽高，那么padding就不会影响盒子的大小。

padding可以城开盒子，因此可以应用于字数不一的情况

![image-20210112171616765](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210112171616765.png)

![image-20210112171800625](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210112171800625.png)

#### 外边距margin

典型应用：盒子水平居中（指定宽度，左右外边距设置为auto）

margin的嵌套：塌陷，如果子元素距离父元素有上边距，父元素会塌陷较大的外边距值。

解决方案：

1.  给父元素增加边框
2. 给父元素定义上内边距
3. 为父元素增加overflow:hidden

#### padding和margin的适用场景

1. margin可以取负值，所以需要用负值时用margin
2. 上下相连的两个盒子之间的空白需要抵消时，例如15px+20px的margin，将得到20px的空白（margin折叠）
3. padding可以有背景色
4. padding可以将上下两个盒子之间的空白变成两者之和，15px+20px会得到35px



### CSS的浮动

竖向排列的用标准流，横向排列的找浮动。

浮动用于创建浮动框，将其移动到一边，知道左边缘/右边缘触及包含块或另一个浮动块的边缘。

1.  浮动元素会脱离标准流，移动到指定的位置，浮动的盒子不再保留原先的位置（浮动的盒子可以叠加在别的标准流的盒子上
2.  如果多个盒子都设置了浮动，则会按照属性值一行内显示并且顶端对齐
3. 浮动元素具有行内块特点，如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动之后，大小根据内容来决定。浮动的盒子中间没有缝隙，是紧挨着一起的。



为了约束浮动元素，经常和标准流的父级搭配使用。

**标准流自己占一行，所以浮动的盒子只会影响后面的盒子，不会影响前面的盒子。



#### overflow:hidden的作用

1. 溢出隐藏（如果内容溢出时，可以省略表示
2. 清除浮动（父元素（没有指定高度时）随子容器和子内容的高度而自适应，清除浮动元素脱离标准流造成的影响
   1.  额外标签法，在最后一个浮动盒子的后面添加一个新的标签，设置属性为{clear: both}，但是有无意义标签，所以结构化比较差。（不常用
   2. overflow:hidden法，代码简洁，但无法显示溢出的部分
   3. :after伪元素法（给父元素添加，给盒子的后面添加一个盒子，有点类似于额外标签，但不需要在html里加，由css自动生成
   4. 双伪元素清除浮动:before, :after
3. 解决外边距塌陷





#### flex布局

flex是一种布局方式，类似于inline-block、block等。基本作用就是让布局变得更简单。在flex中，有一些基本的概念，采用flex布局的元素，成为flex容器，容器内的子元素自动成为flex项目。

![image-20210113024409888](C:\Users\sylwi\AppData\Roaming\Typora\typora-user-images\image-20210113024409888.png)

容器默认存在两根轴：主轴和交叉轴。项目默认沿主轴排列。单个项目占据的主轴空间叫main size，占据的交叉轴空间叫cross size。

flex布局会让子元素的float、clear和vertical-align属性失效。flex是给父容器用的，flex container，所有的子元素自动成为容器成员，称为flex item。

##### 父类的属性

- flex-direction：设置主轴的方向
- flex-wrap：项目是否换行（如果不换行，会修改元素的大小）
- flex-flow：是上两种属性的简写模式
- justify-content：主轴上的对齐方式
- align-items：在交叉轴上如何对齐
- align-content：多根轴线的对齐方式

##### 项目的属性

- order：排列的顺序，数值越小越靠前
- flex-grow：定义项目的放大比例，默认为0
- flex-shrink：项目的缩小比例
- flex-basis：分配多余空间之前，项目占据的主轴空间
- flex：以上三项的简写模式
- align-self：允许单个项目与其他项目不一样的对齐方式



